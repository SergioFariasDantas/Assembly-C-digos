.eqv	num	$s0
.eqv	char	$s1
.eqv	digito	$s2
.eqv	i	$t0
.eqv	k	$t1
.eqv	flag	$t2
.eqv	troca	$t4

.data
ler_Lista:	.asciiz "lista.txt"
escrever_Lista:	.asciiz "lista_ordenada.txt"
buffer:		.space 1024	#Buffer para leitura de dados 
lista:		.space	400	#Espaço da memória usado para armazenar os números da lista
lista_tamanho:	.word	100
newline:	.asciiz"\n"

li	$t8, 200		#Tamanho do array
	.align 2
vetor_num: .space 1024


.text
main:
#Abertura do arquivo para leitura:
	li	$v0, 13		#Abrir arquivo
	la	$a0, ler_Lista
	li	$a1, 0	#modo de leitura
	syscall
	move $s0, $v0

#Leitura do arquivo:
	move	$a0, $s0
	li	$v0, 14		#Comando de Leitura do arquivo
	la	$a1, buffer
	la	$a2, 1024
	syscall

#Fechar o arquivo:
	li	$v0, 16		#COmando de fechamento do arquivo
	move	$a0, $s0
	syscall

#Rotina de retorno do tamanho de uma string para um inteiro:
    li	$t0, 0		# i = 0 (índice do buffer)
    li	$t1, 0		# k = 0 (índice do vetor_num)
    li	$s0, 0		# num = 0
    li	$t2, 1		# flag = 1

loop_1:    
    lb	$s1, buffer($t0)	# Carregar o caractere atual do buffer
    beqz	$s1, fim		# Se for o final da string, sai
    beq	$s1, ',', armazena	# Se for vírgula, armazena
    beq	$s1, '-', negativo	# Se for sinal negativo, trata

converte:
    sub	$s2, $s1, 0x30	# Converte caractere para dígito
    mul	$t3, $s0, 10		# num = num * 10
    add	$s0, $t3, $s2	# num = num + dígito
    addi	$t0, $t0, 1		# i++
    j	loop_1

negativo:
    li	$t2, -1		# flag = -1
    addi	$t0, $t0, 1		# i++
    j	loop_1    

armazena:
    mul	$s0, $s0, $t2		# num = num * flag
    sw	$s0, vetor_num($t1)	# Armazena o número no vetor
    addi	$t1, $t1, 4		# k += 4 (próximo inteiro)
    addi	$t0, $t0, 1		# i++
    li	$s0, 0			# Reseta num para o próximo número
    li	$t2, 1			# Reseta flag para 1
    j	loop_1

fim:
    srl	$t1, $t1, 2		# k = k / 4 (número de inteiros)
    sw	$t1, lista_tamanho	# Armazena o tamanho da lista.eqv	num	$s0
.eqv	char	$s1
.eqv	digito	$s2
.eqv	i	$t0
.eqv	k	$t1
.eqv	flag	$t2
.eqv	troca	$t4

.data
ler_Lista:	.asciiz "lista.txt"
escrever_Lista:	.asciiz "lista_ordenada.txt"
buffer:		.space 1024	#Buffer para leitura de dados 
lista:		.space	400	#Espaço da memória usado para armazenar os números da lista
lista_tamanho:	.word	100
newline:	.asciiz"\n"

li	$t8, 200		#Tamanho do array
	.align 2
vetor_num: .space 1024


.text
main:
#Abertura do arquivo para leitura:
	li	$v0, 13		#Abrir arquivo
	la	$a0, ler_Lista
	li	$a1, 0	#modo de leitura
	syscall
	move $s0, $v0

#Leitura do arquivo:
	move	$a0, $s0
	li	$v0, 14		#Comando de Leitura do arquivo
	la	$a1, buffer
	la	$a2, 1024
	syscall

#Fechar o arquivo:
	li	$v0, 16		#COmando de fechamento do arquivo
	move	$a0, $s0
	syscall

#Rotina de retorno do tamanho de uma string para um inteiro:
    li	$t0, 0		# i = 0 (índice do buffer)
    li	$t1, 0		# k = 0 (índice do vetor_num)
    li	$s0, 0		# num = 0
    li	$t2, 1		# flag = 1

loop_1:    
    lb	$s1, buffer($t0)	# Carregar o caractere atual do buffer
    beqz	$s1, fim		# Se for o final da string, sai
    beq	$s1, ',', armazena	# Se for vírgula, armazena
    beq	$s1, '-', negativo	# Se for sinal negativo, trata

converte:
    sub	$s2, $s1, 0x30	# Converte caractere para dígito
    mul	$t3, $s0, 10		# num = num * 10
    add	$s0, $t3, $s2	# num = num + dígito
    addi	$t0, $t0, 1		# i++
    j	loop_1

negativo:
    li	$t2, -1		# flag = -1
    addi	$t0, $t0, 1		# i++
    j	loop_1    

armazena:
    mul	$s0, $s0, $t2		# num = num * flag
    sw	$s0, vetor_num($t1)	# Armazena o número no vetor
    addi	$t1, $t1, 4		# k += 4 (próximo inteiro)
    addi	$t0, $t0, 1		# i++
    li	$s0, 0			# Reseta num para o próximo número
    li	$t2, 1			# Reseta flag para 1
    j	loop_1

fim:
    srl	$t1, $t1, 2		# k = k / 4 (número de inteiros)
    sw	$t1, lista_tamanho	# Armazena o tamanho da lista
